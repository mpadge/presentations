
This query trawls backwards through the issues, from most recent first. This is
set via `last: 100` rather than `first: 100`, and also requires modified
`pageInfo` to use `hasPreviousPage` rathern than `hasNextPage`, and
`startCursor` rather than `endCursor`.



```{r}
gh_issues_qry <- function (org = "ropensci",
                           backwards = TRUE,
                           end_cursor = NULL) {

    org <- match.arg (org, c ("ropensci", "openjournals"))

    after_txt <- ""
    if (!is.null (end_cursor)) {
        after_txt <- ifelse (backwards,
            paste0 (", before:\"", end_cursor, "\""),
            paste0 (", after:\"", end_cursor, "\"")
        )
    }

    pgInfo1 <- ifelse (backwards, "hasPreviousPage", "hasNextPage")
    pgInfo2 <- ifelse (backwards, "startCursor", "endCursor")

    repo <- ifelse (org == "ropensci", "software-review", "joss-reviews")
    accept_txt <- ifelse (org == "ropensci", "6/approved", "accepted")

        # issues (first: 100, states: [CLOSED], labels: ['", accept_txt, "']" , after_txt, ") {
    q <- paste0 ("{
        repository(owner:\"", org, "\", name:\"", repo, "\") {
        issues (last: 100, states: [CLOSED], labels: \"", accept_txt, "\" " , after_txt, ") {
                       pageInfo {
                           ", pgInfo1, "
                           ", pgInfo2, "
                       }
                       edges {
                           node {
                               ... on Issue {
                                   number
                                   createdAt
                                   state
                                   labels (first: 100) {
                                       edges {
                                           node {
                                               name,
                                           }
                                       }
                                   }
                                   comments (last: 100) {
                                       nodes {
                                           createdAt,
                                           author {
                                               login
                                           },
                                           body
                                       }
                                   }
                               }
                           }
                       }
                   }
                }
        }")

    return (q)
}
```

```{r}
get_dat <- function (org = "ropensci") {

    org <- match.arg (org, c ("ropensci", "openjournals"))
    bot <- ifelse (org == "ropensci", "ropensci-review-bot", c ("whedon", "editorialbot"))

    has_next_page <- TRUE
    end_cursor <- NULL
    comments <- list ()
    page_count <- 0L
    quiet <- FALSE

    number <- created_at <- num_cmts <- num_bot <- NULL

    err_count <- 0
    max_errors <- 5L

    while (has_next_page) {

        q <- gh_issues_qry (
            org = org,
            backwards = FALSE,
            end_cursor = end_cursor
        )
        dat <- tryCatch (
            gh::gh_gql (query = q),
            error = function (e) NULL
        )

        if (err_count > max_errors) {
            break
        }

        if (is.null (dat)) {
            err_count <- err_count + 1L
            next
        }

        has_next_page <- dat$data$repository$issues$pageInfo$hasNextPage
        end_cursor <- dat$data$repository$issues$pageInfo$endCursor

        edges <- dat$data$repository$issues$edges

        number <- c (
            number,
            vapply (edges, function (i) i$node$number, integer (1L))
        )
        created_at <- c (
            created_at,
            vapply (edges, function (i) {
                strftime (i$node$createdAt, "%Y-%m-%d")
            }, character (1L))
        )
        cmt_dat <- vapply (edges, function (i) {
            cmts <- i$node$comments$nodes
            auths <- vapply (cmts, function (j) {
                res <- j$author$login
                ifelse (is.null (res), NA_character_, res)
            }, character (1L))
            n_bot <- length (which (auths %in% bot))
            c (length (cmts), n_bot)
        }, integer (2L))
        num_cmts <- c (num_cmts, cmt_dat [1, ])
        num_bot <- c (num_bot, cmt_dat [2, ])

        page_count <- page_count + 1L
        if (!quiet) {
            message (
                "Retrieved page [", page_count, "] to issue number [",
                max (number), "]"
            )
        }
    }

    data.frame (
        number = number,
        created_at = created_at,
        num_cmts = num_cmts,
        num_bot = num_bot
    )
}
```
```{r}
dat_r <- get_dat (org = "ropensci")
saveRDS (dat_r, "gh-cmt-data-ropensci.Rds")
dat_j <- get_dat (org = "openjournals")
saveRDS (dat_j, "gh-cmt-data-joss.Rds")
```

```{r}
dat_r <- readRDS ("gh-cmt-data-ropensci.Rds")
dat_j <- readRDS ("gh-cmt-data-joss.Rds")
```





